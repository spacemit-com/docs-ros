# 3.4.2 JDK ç¤ºä¾‹å‚è€ƒ

æœ¬èŠ‚æä¾› **JDK å¤šåª’ä½“å¤„ç†åº“çš„å®ç”¨ç¤ºä¾‹**ã€‚å†…å®¹ä»åŸºç¡€ API ä½¿ç”¨å¼€å§‹ï¼Œé€æ­¥å±•ç¤ºå®Œæ•´åº”ç”¨æµæ°´çº¿ã€‚

## åŸºç¡€ç¤ºä¾‹

### JDK æ•°æ®å¸§æ ¼å¼

`JdkFrame` æ˜¯å„æ¨¡å—ä¹‹é—´ä¼ é€’å›¾åƒçš„ç»Ÿä¸€æ•°æ®ç»“æ„:

```c++
class JdkFrame {
public:
    JdkFrame(int dma_fd_, size_t size_, int w, int h);
    ~JdkFrame();

    // æ‹·è´ DMA ç¼“å†²åŒºæ•°æ®åˆ°ä¸»æœºå†…å­˜å¹¶è¿”å›æŒ‡é’ˆ
    unsigned char* toHost() const;

    // å…‹éš†æ•°æ®è‡³ vector
    std::vector<unsigned char> Clone() const;

    // æ‰‹åŠ¨é‡Šæ”¾æ˜ å°„ï¼ˆå¦‚æœ‰å¿…è¦ï¼‰
    // ä¿å­˜ä¸º YUV NV12 æ ¼å¼æ–‡ä»¶
    bool saveToFile(const std::string& filename) const;
    bool loadFromFile(const std::string& filename, size_t expected_size);

    int getDMAFd() const;
    size_t getSize() const { return size_; }
    int getWidth() const { return width_; }
    int getHeight() const { return height_; }

    int MemCopy(const uint8_t* nalu, int nalu_size, int offset = 0);

private:
    size_t size_;   // æ•°æ®æ€»å¤§å°ï¼ŒNV12æ ¼å¼å®½é«˜ç›¸å…³
    int width_;
    int height_;
    JdkDma dma_;
    std::shared_ptr<JdkDmaBuffer> data;
};
```

### MIPI æ‘„åƒå¤´é‡‡é›† (`JdkCamera`)

```c++
// æ‰“å¼€æ‘„åƒèŠ‚ç‚¹
auto camera = JdkCamera::create("/device/video50", 1920, 1080, V4L2_PIX_FMT_NV12); 

// è·å–ä¸€å¸§æ•°æ®
auto frame = camera->getFrame(); 
```

### ç¼–ç ï¼ˆ`JdkEncoder`ï¼‰

```c++
// åˆ›å»ºç¼–ç å™¨
auto encoder = std::make_shared<JdkEncoder>(width, height, CODING_H264, PIXEL_FORMAT_NV12);

// å¯¹å•å¸§æ•°æ®è¿›è¡Œç¼–ç 
auto encodedFrame = encoder->Encode(jdkFrame);
```

### è§£ç ï¼ˆ`JdkDecoder`ï¼‰

```c++
// åˆ›å»ºè§£ç å™¨
auto decoder = std::make_shared<JdkDecoder>(width, height, CODING_H264, PIXEL_FORMAT_NV12);

// å¯¹å•å¸§æ•°æ®è¿›è¡Œè§£ç 
auto decodedFrame = decoder->Decode(jdkFrame);
```

### å›¾åƒå¤„ç†ï¼ˆ`JdkV2D`ï¼‰

```c++
// åˆ›å»º V2D æ¨¡å—å®ä¾‹
auto v2d = std::make_shared<JdkV2D>();

// NV12 è½¬æ¢ä¸º RGB8888 æ ¼å¼
auto rgba_frame = v2d->convert_format(input_nv12, V2D_FMT_RGB888);

// ç»˜åˆ¶å•ä¸ªçŸ©å½¢æ¡†
v2d->draw_rect(input_nv12, box, 0xFFFFFF00, 4); // é»„è‰²ï¼Œçº¿å®½4

// ç»˜åˆ¶å¤šä¸ªçŸ©å½¢æ¡†
v2d->draw_rects(input_nv12, {{30, 20, 100, 80}, {60, 40, 200, 160}}, 0x00ffcc66, 4); // çº¿å®½4

// å¯¹å¸§æ•°æ®ç¼©æ”¾
auto resized_frame = v2d->resize(jdkFrame, 1920, 1080);

// åŒæ—¶ç¼©æ”¾å¹¶æ ¼å¼è½¬æ¢
auto converted_frame = v2d->resize_and_convert(jdkFrame, 1920, 1080, V2D_FMT_RGB888);
```

### SDL æ˜¾ç¤ºï¼ˆ`JdkVo`ï¼‰

```c++
// åˆ›å»ºè§†é¢‘è¾“å‡ºï¼ˆVOï¼‰å¯¹è±¡
auto jdkvo = std::make_shared<JdkVo>(width, height, PIXEL_FORMAT_NV12);

// æ˜¾ç¤ºä¸€å¸§å›¾åƒ
auto ret = jdkvo->sendFrame(jdkFrame);
```

### DRM æ˜¾ç¤ºï¼ˆ`JdkDrm`ï¼‰

```c++
// åˆ›å»º DRM å¯¹è±¡
auto drm = std::make_shared<JdkDrm>(width, height, width, PixelFmt::NV12, "/dev/dri/card1");

// æ˜¾ç¤ºä¸€å¸§å›¾åƒ
auto ret = drm->sendFrame(jdkFrame1);
```

### AI æ¨ç†ï¼ˆ`YOLOV8Det`ï¼‰

```c++
// åˆ›å»ºç®—æ³•æ¨ç†å¼•æ“å®ä¾‹
auto engine = YOLOV8Det::create_infer("yolov8n.q.onnx", "onnx");

// å¯¹å¸§æ•°æ®è¿›è¡Œæ¨ç†
auto result = engine->commit(jdkFrame).get();

// ç»˜åˆ¶æ¨ç†ç»“æœ
draw_nv12(jdkFrame, std::any_cast<YOLOV8Det::Objects>(result));
```

## æ„å»ºä¸è¿è¡Œç¤ºä¾‹

æœ¬èŠ‚å±•ç¤ºå¦‚ä½•é…ç½® SDKã€ç¼–è¯‘æ¨¡å—ä»¥åŠè¿è¡Œç¤ºä¾‹ç¨‹åºã€‚

### JDK SDK ä¸‹è½½ä¸å®‰è£…

```bash
wget https://archive.spacemit.com/ros2/code/jdk_sdk.tar.gz
sudo tar xvf jdk_sdk.tar.gz
```

ç›®å½•ç»“æ„å¦‚ä¸‹ï¼š

```shell
jdk_sdk
â”œâ”€â”€ include
â”‚Â Â  â”œâ”€â”€ data_type.hpp
â”‚Â Â  â”œâ”€â”€ IConver.hpp
â”‚Â Â  â”œâ”€â”€ IEngine.hpp
â”‚Â Â  â”œâ”€â”€ IPlugin.hpp
â”‚Â Â  â”œâ”€â”€ ITensor.hpp
â”‚Â Â  â”œâ”€â”€ JdkCamera.hpp
â”‚Â Â  â”œâ”€â”€ JdkDecoder.hpp
â”‚Â Â  â”œâ”€â”€ JdkDma.hpp
â”‚Â Â  â”œâ”€â”€ JdkDrm.hpp
â”‚Â Â  â”œâ”€â”€ JdkEncoder.hpp
â”‚Â Â  â”œâ”€â”€ JdkFrame.hpp
â”‚Â Â  â”œâ”€â”€ jdk_log.h
â”‚Â Â  â”œâ”€â”€ JdkUsbCam.hpp
â”‚Â Â  â”œâ”€â”€ jdkV2d.hpp
â”‚Â Â  â”œâ”€â”€ JdkVo.hpp
â”‚Â Â  â”œâ”€â”€ json.hpp
â”‚Â Â  â””â”€â”€ Tensor.hpp
â”œâ”€â”€ jdk_examples
â”‚Â Â  â”œâ”€â”€ jdk_cam
â”‚Â Â  â”œâ”€â”€ jdk_client
â”‚Â Â  â”œâ”€â”€ jdk_drm
â”‚Â Â  â”œâ”€â”€ jdk_frame
â”‚Â Â  â”œâ”€â”€ jdk_infer
â”‚Â Â  â”œâ”€â”€ jdk_infer@rtsp
â”‚Â Â  â”œâ”€â”€ jdk_server
â”‚Â Â  â”œâ”€â”€ jdk_usbcam
â”‚Â Â  â”œâ”€â”€ jdk_v2d
â”‚Â Â  â”œâ”€â”€ jdk_vdec
â”‚Â Â  â”œâ”€â”€ jdk_venc
â”‚Â Â  â””â”€â”€ jdk_vo
â”œâ”€â”€ ko
â”‚Â Â  â””â”€â”€ jdk_dma.ko
â”œâ”€â”€ lib
â”‚Â Â  â”œâ”€â”€ libengine.so
â”‚Â Â  â”œâ”€â”€ libjdk_cam.so
â”‚Â Â  â”œâ”€â”€ libjdk_dma.so
â”‚Â Â  â”œâ”€â”€ libjdk_drm.so
â”‚Â Â  â”œâ”€â”€ libjdk_frame.so
â”‚Â Â  â”œâ”€â”€ libjdk_usbcam.so
â”‚Â Â  â”œâ”€â”€ libjdk_v2d.so
â”‚Â Â  â”œâ”€â”€ libjdk_vdec.so
â”‚Â Â  â”œâ”€â”€ libjdk_venc.so
â”‚Â Â  â”œâ”€â”€ libjdk_vo.so
â”‚Â Â  â”œâ”€â”€ libnet_client.so
â”‚Â Â  â””â”€â”€ libnet_server.so
â”œâ”€â”€ Makefile
â””â”€â”€ README.md
```

### ç¤ºä¾‹è¯´æ˜

```bash
jdk_examples
â”œâ”€â”€ jdk_cam       # æ‘„åƒå¤´æ¨¡å—
â”œâ”€â”€ jdk_client    # å®¢æˆ·ç«¯æ¨¡å—
â”œâ”€â”€ jdk_drm       # DRM ç›¸å…³æ¨¡å—
â”œâ”€â”€ jdk_frame     # å¸§å¤„ç†æ¨¡å—
â”œâ”€â”€ jdk_infer     # æ¨ç†æ¨¡å—
â”œâ”€â”€ jdk_infer@rtsp# è§†é¢‘é‡‡é›†RTSPè¾“å‡ºå’Œå¹¶è¡Œæ¨ç†
â”œâ”€â”€ jdk_server    # æœåŠ¡ç«¯æ¨¡å—
â”œâ”€â”€ jdk_v2d       # è§†é¢‘äºŒç»´æ¨¡å—
â”œâ”€â”€ jdk_vdec      # è§†é¢‘è§£ç æ¨¡å—
â”œâ”€â”€ jdk_venc      # è§†é¢‘ç¼–ç æ¨¡å—
â””â”€â”€ jdk_vo        # è§†é¢‘è¾“å‡ºæ¨¡å—
```

### ç¼–è¯‘ç¤ºä¾‹ç¨‹åº

è¿›å…¥æ‘„åƒå¤´æ¨¡å—ç›®å½•å¹¶ç¼–è¯‘ç¤ºä¾‹ï¼š

```bash
cd jdk_sdk
make all
```

ç¤ºä¾‹ç¼–è¯‘è¾“å‡ºï¼š

```bash
make -C jdk_examples/jdk_cam all
make[1]: Entering directory '/home/work/jdk_sdk/jdk_examples/jdk_cam'
Compile depends C++ src/main.cpp
Compile CXX src/main.cpp
Link workspace/jdk_cam
```

### è¿è¡Œç¤ºä¾‹

åœ¨è¿è¡Œ JDK ç¤ºä¾‹å‰ï¼Œéœ€è¦å…ˆå®‰è£… JDK DMA é©±åŠ¨ã€‚

```shell
insmod ./ko/jdk_dma.ko
cd jdk_examples/jdk_usbcam
./workspace/jdk_usbcam /dev/video20
```

> ğŸš¨ æç¤ºï¼šè¯·æ ¹æ®å®é™…æƒ…å†µç¡®è®¤è®¾å¤‡èŠ‚ç‚¹è·¯å¾„ï¼Œå¦‚ `/dev/video20`ã€‚å¯é€šè¿‡ `v4l2-ctl --list-devices` å‘½ä»¤æŸ¥çœ‹è®¾å¤‡ä¿¡æ¯ã€‚

è¿è¡Œåç»ˆç«¯å°†è¾“å‡ºæ¨¡å—åˆå§‹åŒ–ä¸å›¾åƒé‡‡é›†çš„æ—¥å¿—ä¿¡æ¯ã€‚

### å¯åŠ¨æ—¥å¿—ç¤ºä¾‹

~~~shell
VIDIOC_STREAMON succeeded
[MPP-DEBUG] 10800:module_init:159 +++++++++++++++ module init, module type = 9
[MPP-DEBUG] 10800:find_v4l2_linlonv5v7_plugin:83 yeah! we have v4l2_linlonv5v7_codec plugin---------------
[MPP-DEBUG] 10800:module_init:199 ++++++++++ V4L2_LINLONV5V7 (/usr/lib/libv4l2_linlonv5v7_codec.so)
[MPP-DEBUG] 10800:module_init:199 ++++++++++ open (/usr/lib/libv4l2_linlonv5v7_codec.so) success !
[MPP-DEBUG] 10800:al_dec_create:337 init create
[MPP-DEBUG] 10800:al_dec_init:398 input para check: foramt:0x4745504a output format:0x3231564e input buffer num:12 output buffer num:8
[MPP-DEBUG] 10800:al_dec_init:421 video fd = 4, device path = '/dev/video0'
[MPP-DEBUG] 10800:createCodec:115 create a codec, width=1280 height=720 align=1 inputtype=2 outputtype=9 inputformat=4745504a outputformat=3231564e inputbufnum=12 outputbufnum=8
[MPP-DEBUG] 10800:createPort:80 create a port, type=2 format_fourcc=1195724874
[MPP-DEBUG] 10800:createPort:80 create a port, type=9 format_fourcc=842094158
[MPP-DEBUG] 10800:getTrySetFormat:196 width=1280 height=720 align=1 pixel_format=4745504a
[MPP-DEBUG] 10800:printFormat:294 PRINTFORMAT ===== type: 2, format: 1195724874, width: 1280, height: 720, bytesperline: 0, sizeimage: 1048576
[MPP-DEBUG] 10800:getTrySetFormat:196 width=1280 height=720 align=1 pixel_format=3231564e
[MPP-DEBUG] 10800:printFormat:283 PRINTFORMAT ===== type: 9, format: 842094158, width: 1280, height: 720, nplanes: 2, bytesperline: [1280 1280 0], sizeimage: [921600 460800 0]
[MPP-DEBUG] 10800:allocateBuffers:340 Request buffers. type:2 count:12(12) memory:1
[MPP-DEBUG] 10800:allocateBuffers:340 Request buffers. type:9 count:8(8) memory:4
[MPP-DEBUG] 10800:streamon:558 Stream on 1751956058513
[MPP-DEBUG] 10800:streamon:558 Stream on 1751956058513
[MPP-DEBUG] 10800:al_dec_init:449 init finish
[MPP-DEBUG] 10800:VO_CreateChannel:43 create VO Channel success!
[MPP-DEBUG] 10800:module_init:159 +++++++++++++++ module init, module type = 101
[MPP-DEBUG] 10800:check_vo_sdl2:121 yeah! have vo_sdl2---------------
[MPP-DEBUG] 10800:find_vo_sdl2_plugin:86 yeah! we have vo_sdl2_plugin plugin---------------
[MPP-DEBUG] 10800:module_init:207 ++++++++++ VO_SDL2 (/usr/lib/libvo_sdl2_plugin.so)
[MPP-DEBUG] 10800:module_init:207 ++++++++++ open (/usr/lib/libvo_sdl2_plugin.so) success !
[MPP-ERROR] 10800:al_vo_init:93 SDL could not initialize! SDL_Error: wayland not available
[MPP-ERROR] 10800:al_vo_init:128 k1 vo_sdl2 init fail
[MPP-DEBUG] 10800:VO_Init:66 init VO Channel, ret = -400
[MPP-ERROR] 10800:JdkVo:32 VO_init failed, please check!
[MPP-INFO] 10801:runpoll:321 Now k1 hardware decoding ...
select: Resource temporarily unavailable
Failed to capture frame 0
NO data, return.
[MPP-DEBUG] 10801:handleEvent:453 get V4L2_EVENT_SOURCE_CHANGE event, do notify!
[MPP-DEBUG] 10800:handleOutputBuffer:1509 Resolution changed:0 new size: 1280 x 720
[MPP-DEBUG] 10800:streamoff:571 Stream off 1751956060839
[MPP-DEBUG] 10800:allocateBuffers:340 Request buffers. type:9 count:0(0) memory:4
[MPP-DEBUG] 10800:getTrySetFormat:196 width=1280 height=720 align=1 pixel_format=3231564e
[MPP-DEBUG] 10800:printFormat:283 PRINTFORMAT ===== type: 9, format: 842094158, width: 1280, height: 720, nplanes: 2, bytesperline: [1280 1280 0], sizeimage: [921600 460800 0]
[MPP-DEBUG] 10800:allocateBuffers:340 Request buffers. type:9 count:12(12) memory:4
[MPP-DEBUG] 10800:streamon:558 Stream on 1751956060850
[MPP-ERROR] 10800:queueBuffer:461 Failed to queue buffer. type = 9 (Invalid argument)
[MPP-ERROR] 10800:al_dec_return_output_frame:652 queueBuffer failed, this should not happen, please check!
[MPP-DEBUG] 10800:VO_Process:82 vo one packet, ret = 0
index:1,dma_fd:33 width:1280,height:720,size:1382400
[MPP-DEBUG] 10800:VO_Process:82 vo one packet, ret = 0
index:2,dma_fd:33 width:1280,height:720,size:1382400
[MPP-DEBUG] 10800:VO_Process:82 vo one packet, ret = 0
index:3,dma_fd:33 width:1280,height:720,size:1382400
~~~

## å®Œæ•´æµæ°´çº¿ç¤ºä¾‹

è¿™äº›ç¤ºä¾‹å°†å¤šä¸ªæ¨¡å—ç»„åˆæˆç«¯åˆ°ç«¯è§†è§‰å·¥ä½œæµã€‚

### ç¤ºä¾‹ 1ï¼šUSB æ‘„åƒå¤´ â†’ è§£ç  â†’ æ˜¾ç¤º

```c++
// æ‰“å¼€æ‘„åƒå¤´èŠ‚ç‚¹
auto camera = JdkUsbCam::create(device, width, height, V4L2_PIX_FMT_MJPEG);
// åˆ›å»º JPEG è§£ç å™¨
auto decoder = std::make_shared<JdkDecoder>(width, height, CODING_MJPEG, PIXEL_FORMAT_NV12);
// åˆå§‹åŒ–æ˜¾ç¤ºæ¨¡å—ï¼ˆvoï¼‰
auto jdkvo = std::make_shared<JdkVo>(width, height, PIXEL_FORMAT_NV12);
// è·å–ä¸€å¸§å›¾åƒæ•°æ®
auto frame = camera->getFrame();
// è§£ç  JPEG å›¾åƒ
auto decFrame = decoder->Decode(frame)
// å°†å›¾åƒå¸§å‘é€è‡³æ˜¾ç¤ºæ¨¡å—
auto ret = jdkvo->sendFrame(decFrame);
```

### ç¤ºä¾‹ 2ï¼šMIPI æ‘„åƒå¤´é‡‡é›† â†’ å®æ—¶æ˜¾ç¤º

```c++
// æ‰“å¼€æ‘„åƒå¤´èŠ‚ç‚¹
auto camera = JdkCamera::create("/device/video50", 1920, 1080, V4L2_PIX_FMT_NV12);
// åˆå§‹åŒ–æ˜¾ç¤ºæ¨¡å—ï¼ˆvoï¼‰
auto jdkvo = std::make_shared<JdkVo>(1920, 1080, PIXEL_FORMAT_NV12);
// è·å–ä¸€å¸§å›¾åƒæ•°æ®
auto frame = camera->getFrame();
// å°†å›¾åƒå¸§å‘é€è‡³æ˜¾ç¤ºæ¨¡å—
auto ret = jdkvo->sendFrame(frame);
```

### ç¤ºä¾‹ 3ï¼šMIPI æ‘„åƒå¤´ â†’ ç¼–ç  â†’ RTSP æ¨æµ

```c++
// åˆ›å»ºæ‘„åƒå¤´é‡‡é›†å¯¹è±¡
auto camera = JdkCamera::create("/dev/video50", width, height, V4L2_PIX_FMT_NV12);

// åˆ›å»ºç¼–ç å™¨å¯¹è±¡
auto encoder = std::make_shared<JdkEncoder>(width, height, CODING_H264, PIXEL_FORMAT_NV12);

// åˆ›å»º RTSP æœåŠ¡å™¨
auto rtsp_ = std::make_shared<RTSPServer>("test", 1, 8554, VideoCodecType::H264);

while (running) {
    auto frame = camera->getFrame(); // è·å–ä¸€å¸§å›¾åƒ
    if (!frame) {
        std::cerr << "Failed to capture frame\n";
        continue;
    }
    auto encFrame = encoder->Encode(frame); // ç¼–ç 
    if (encFrame) {
        size_t sz = encFrame->getSize();
        uint8_t* data = (uint8_t*)encFrame->toHost();
        rtsp_->send_nalu(data, sz, getTimestamp()); // æ¨é€ç¼–ç æ•°æ®
    }
}
```

### ç¤ºä¾‹ 4ï¼šRTSP â†’ è§£ç  â†’ DRM æ˜¾ç¤º

```c++
// åˆ›å»º RTSP å®¢æˆ·ç«¯
auto netclient = std::make_shared<NetClient>(device_id, channel_id, 0, "");

// åˆ›å»º JDK è§£ç å™¨
auto decoder = std::make_shared<JdkDecoder>(width, height, CODING_H264, PIXEL_FORMAT_NV12);

// å¯åŠ¨æ¥æ”¶ç æµ
netclient->start("rtsp://admin:123456@169.254.202.148:8554/stream_8554");

// ç»‘å®šè§†é¢‘å›è°ƒå‡½æ•°
video_cb_ = std::bind(&NetClient::rtsp_video_cb, this,
                      std::placeholders::_1, std::placeholders::_2,
                      std::placeholders::_3, std::placeholders::_4,
                      std::placeholders::_5);

// è§†é¢‘å›è°ƒå‡½æ•°å®ç°
int NetClient::rtsp_video_cb(LPBYTE pdata, int len, unsigned int ts,
                             unsigned short seq, void* puser) {
    if (!decoder_) {
        // åˆå§‹åŒ–è§£ç å™¨åŠ DRM æ˜¾ç¤ºæ¨¡å—
        decoder_ = std::make_shared<JdkDecoder>(info_tmp->video.width,
                                                info_tmp->video.height,
                                                CODING_H264, PIXEL_FORMAT_NV12);

        drm_ = std::make_shared<JdkDrm>(info_tmp->video.width,
                                        info_tmp->video.height,
                                        info_tmp->video.width,
                                        PixelFmt::NV12, "/dev/dri/card1");

        drmframe = std::make_shared<JdkFrame>(-1,
                                              info_tmp->video.width * info_tmp->video.height * 3 / 2,
                                              info_tmp->video.width,
                                              info_tmp->video.height);
    } else {
        frame = decoder_->Decode(pdata, len);         // è§£ç 
        drmframe->MemCopy(frame->toHost(), frame->getSize()); // æ‹·è´æ•°æ®åˆ°æ˜¾ç¤ºç¼“å†²åŒº
        drm_->sendFrame(drmframe);                     // æ˜¾ç¤ºå›¾åƒ
    }
}
```

### ç¤ºä¾‹ 5ï¼šMIPI æ‘„åƒå¤´ â†’ YOLOv8 æ¨ç† â†’ ç”»æ¡† â†’ æ˜¾ç¤º

```c++
// åˆ›å»ºæ‘„åƒå¤´é‡‡é›†å¯¹è±¡
auto camera = JdkCamera::create("/dev/video50", width, height, V4L2_PIX_FMT_NV12);
// åˆå§‹åŒ–æ˜¾ç¤ºæ¨¡å—ï¼ˆvoï¼‰
auto jdkvo = std::make_shared<JdkVo>(width, height, PIXEL_FORMAT_NV12);
// åˆ›å»ºç®—æ³•æ¨ç†å¼•æ“å®ä¾‹
auto engine = YOLOV8Det::create_infer("yolov8n.q.onnx", "onnx");
//åˆå§‹åŒ– v2dæ¨¡å—
auto v2d = std::make_shared<JdkV2D>();
// è·å–ä¸€å¸§å›¾åƒæ•°æ®
auto jdkFrame = camera->getFrame();
// å¯¹å¸§æ•°æ®è¿›è¡Œæ¨ç†
auto result = engine->commit(jdkFrame).get();
//é€šè¿‡v2dæ¨¡å—è¿›è¡Œå æ¡†
draw_nv12(jdkFrame, std::any_cast<YOLOV8Det::Objects>(result));
int draw_nv12(std::shared_ptr<JdkFrame> frame, YOLOV8Det::Objects box_result)
{
    // printf(" box_result.size:%d\r\n", box_result.size());
    auto v2d = std::make_shared<JdkV2D>();
    auto reult = v2d->resize(frame, 320, 320);
    reult->saveToFile("320x320_resize.nv12");
    auto boxs = box_result[0].boxs;
    for (int i = 0; i < boxs.size(); ++i)
    {
        auto &ibox = boxs[i];
        float left = ibox.rect.tl().x;
        float top = ibox.rect.tl().y;
        float right = ibox.rect.br().x;
        float bottom = ibox.rect.br().y;
        int class_label = ibox.label;
        float confidence = ibox.prob;
        v2d->draw_rect(reult, {ibox.rect.x, ibox.rect.y, ibox.rect.width, ibox.rect.height}, 0xFFFF00, 2);
    }
    // mkdir(save_dir);
    // auto save_file = save_dir + "/" + file;
    // cv::imwrite(save_file.data(), image);
    // reult->saveToFile("320x320_OSD_result.nv12");
    return 0;
}
// å°†å›¾åƒå¸§å‘é€è‡³æ˜¾ç¤ºæ¨¡å—è¿›è¡Œæ˜¾ç¤º
auto ret = jdkvo->sendFrame(jdkFrame);
```

### ç¤ºä¾‹ 6ï¼šMIPI æ‘„åƒå¤´ â†’ YOLOv8 æ¨ç† + RTSP å®æ—¶ç¼–ç æ¨æµ(å¹¶è¡Œè¾“å‡º)

```shell
std::atomic<bool>					  running(true);
safe_queue<std::shared_ptr<JdkFrame>> queue;

void input_thread() {
	std::string wait;
	std::getline(std::cin, wait);
	running = false;
}

void infer_thread() {
	auto Engin = YOLOV8Det::create_infer("yolov8n.q.onnx", "onnx");
	if (nullptr == Engin) {
		printf("create_infer error!!!!\r\n");
		return;
	}

	while (running) {
		auto frame = queue.get(&running);
		if (!frame) {
			printf("Warning: frame is NULL!\n");
			continue;
		}
		auto result = Engin->commit(frame).get();
	}
}

static uint32_t getTimestamp() {
	struct timeval tv = {0};
	gettimeofday(&tv, NULL);
	uint32_t ts = ((tv.tv_sec * 1000) + ((tv.tv_usec + 500) / 1000)) * 90;	// clockRate/1000;
	return ts;
}

int main(int argc, char *argv[]) {
	int	 width	= 1920;
	int	 height = 1080;
	auto camera = JdkCamera::create("/dev/video50", width, height, V4L2_PIX_FMT_NV12);
	if (!camera) {
		std::cerr << "Failed to create camera\n";
		return -1;
	}
	auto encoder = std::make_shared<JdkEncoder>(width, height, CODING_H264, PIXEL_FORMAT_NV12);
	auto rtsp_	 = std::make_shared<RTSPServer>("test", 1, 8554, VideoCodecType::H264);

	std::thread th(input_thread);
	std::thread th_infer(infer_thread);

	while (running) {
		auto frame = camera->getFrame();
		if (!frame) {
			std::cerr << "Failed to capture frame " << "\n";
			continue;
		}
		queue.push(frame, &running);
		if (auto encFrame = encoder->Encode(frame); encFrame) {
			size_t	 sz	  = encFrame->getSize();
			uint8_t *data = (uint8_t *)encFrame->toHost();
			rtsp_->send_nalu(data, sz, getTimestamp());
		}
		static int i = 0;
		if ((i % 5000) == 0) {
			printf("dma_fd:%d width:%d,height:%d,size:%d\r\n", frame->getDMAFd(), frame->getWidth(), frame->getHeight(), frame->getSize());
		}
	}

	if (th.joinable())
		th.join();
	if (th_infer.joinable())
		th_infer.join();
	std::cout << "âœ… Exited by user input." << std::endl;

	return 0;
}
```

## å¸¸è§é—®é¢˜ä¸å»ºè®®

| é—®é¢˜           | è¯´æ˜                                            |
| -------------- | ----------------------------------------------- |
| æ£€æµ‹ä¸åˆ°æ‘„åƒå¤´ | æ£€æŸ¥ USB æ¥å£è¿æ¥ã€å°è¯•å…¶ä»–ç«¯å£ã€ç¡®è®¤æ‘„åƒå¤´å‹å· |
| æ‘„åƒå¤´æ‰“ä¸å¼€   | å¯èƒ½æ‘„åƒå¤´æœªè¢«è¯†åˆ«ï¼Œæˆ–é©±åŠ¨ä¸æ”¯æŒ                |
| SDL æŠ¥é”™       | ç³»ç»Ÿå›¾å½¢åº“ä¾èµ–ç¼ºå¤±ï¼Œä¸å½±å“æ‘„åƒå¤´é‡‡é›†åŠŸèƒ½        |
| å›¾åƒä¸æ˜¾ç¤º     | æ£€æŸ¥ vo åˆå§‹åŒ–æ—¥å¿—ã€ç¡®è®¤ä½¿ç”¨çš„æ˜¾ç¤ºé€šé“å’Œæƒé™    |
